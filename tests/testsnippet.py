# Code Generated by Gemini to deal with all unit test cases I outlined
# Will deal with this when I get home
import os
import pytest
from fastapi.testclient import TestClient
from sqlmodel import Session, SQLModel, create_engine
from decimal import Decimal

# Import your app, dependencies, and models
from api.main import app
from api.database import get_session
from api.models import UploadData, SummaryData

# --- Test Setup ---
# All the setup code is now at the top of this single test file.

# Use an in-memory SQLite database for fast, isolated tests
TEST_DATABASE_URL = "sqlite:///:memory:"
engine = create_engine(
    TEST_DATABASE_URL,
    connect_args={"check_same_thread": False},
)


# This is the override function that provides a session from the TEST database
def override_get_session():
    session = Session(engine)
    try:
        yield session
    finally:
        session.close()


# Apply the dependency override to the app
app.dependency_overrides[get_session] = override_get_session

# Create the TestClient that uses the modified app
client = TestClient(app)

# --- Test Data ---
# A reusable set of data for the summary tests
summary_test_data = [
    {
        "transaction_id": "95494198-1b28-4b68-9fe1-48da933d0104",
        "user_id": 622,
        "product_id": 465,
        "timestamp": "2024-11-03T19:17:50",
        "transaction_amount": 424.19,
    },
    {
        "transaction_id": "e47470dc-2aba-42cc-9daf-24b55c492efd",
        "user_id": 622,
        "product_id": 207,
        "timestamp": "2025-02-16T01:09:42",
        "transaction_amount": 496.82,
    },
    {
        "transaction_id": "905ac509-22cd-4aa6-8b30-1181c0139447",
        "user_id": 622,
        "product_id": 7,
        "timestamp": "2025-07-06T10:18:46",
        "transaction_amount": 85.45,
    },
]


# --- Test Cases ---


def setup_function():
    """Create tables before each test."""
    SQLModel.metadata.create_all(engine)


def teardown_function():
    """Drop tables after each test."""
    SQLModel.metadata.drop_all(engine)


class TestUploadEndpoint:
    def test_upload_success(self):
        """Tests successful CSV upload."""
        file_path = os.path.join(os.path.dirname(__file__), "dummy_transactions.csv")
        with open(file_path, "rb") as f:
            response = client.post(
                "/upload", files={"file": ("dummy_transactions.csv", f, "text/csv")}
            )
        assert response.status_code == 201
        # Check the number of rows in your dummy_transactions.csv
        assert response.json() == {
            "message": "Successfully uploaded and processed 10 transactions."
        }

    def test_upload_invalid_file_type(self):
        """Tests upload with a non-CSV file."""
        file_path = os.path.join(os.path.dirname(__file__), "invalid_file.txt")
        with open(file_path, "rb") as f:
            response = client.post(
                "/upload", files={"file": ("invalid_file.txt", f, "text/plain")}
            )
        assert response.status_code == 400
        assert "Invalid file type" in response.json()["detail"]


class TestSummaryEndpoint:
    def test_summary_for_valid_user_no_dates(self, session: Session):
        """Tests the happy path for a user with multiple transactions, no date filter."""
        for item in summary_test_data:
            transaction = UploadData.model_validate(item)
            session.add(transaction)
        session.commit()

        response = client.get("/summary/622")

        assert response.status_code == 200
        data = response.json()
        assert Decimal(data["max_amount"]) == Decimal("496.82")
        assert Decimal(data["min_amount"]) == Decimal("85.45")

    def test_summary_for_invalid_user(self, session: Session):
        """Tests the error case for a user ID that does not exist."""
        response = client.get("/summary/999")
        assert response.status_code == 404
        assert "No transactions found" in response.json()["detail"]

    def test_summary_with_date_range_success(self, session: Session):
        """Tests a successful query with a valid date range."""
        for item in summary_test_data:
            transaction = UploadData.model_validate(item)
            session.add(transaction)
        session.commit()

        response = client.get("/summary/622?start_date=2025-01-01&end_date=2025-12-31")

        assert response.status_code == 200
        data = response.json()
        # Only two transactions for user 622 are in 2025
        assert Decimal(data["max_amount"]) == Decimal("496.82")
        assert Decimal(data["min_amount"]) == Decimal("85.45")
        assert data["transaction_count"] == 2

    def test_summary_no_transactions_in_date_range(self, session: Session):
        """Tests the case where a valid user has no transactions in the specified range."""
        for item in summary_test_data:
            transaction = UploadData.model_validate(item)
            session.add(transaction)
        session.commit()

        response = client.get("/summary/622?start_date=2023-01-01&end_date=2023-12-31")
        assert response.status_code == 404

    def test_summary_invalid_date_range(self, session: Session):
        """Tests the error case where start_date is after end_date."""
        response = client.get("/summary/622?start_date=2025-01-01&end_date=2024-01-01")
        assert response.status_code == 400
        assert "start_date cannot be after end_date" in response.json()["detail"]
